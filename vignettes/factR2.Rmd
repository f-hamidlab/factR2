---
title: "Working with custom transcriptomes using factR2"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{factR2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r silent.setup, echo=FALSE, include=FALSE}
library(factR2)
library(tidyverse)
library(rtracklayer)
```




## Introduction 

Many eukaryotic genes undergo alternative splicing to produce multiple RNA 
isoforms, thus expanding the coding and regulatory potential of the genome. 
The transcriptome of specific biological samples are constructed from high 
throughput sequencing by mapping short or long reads to a reference genome 
and assembling alignments into transcript architectures. The resulting Gene 
Transfer Format (GTF) files describe newly identified transcripts as sets of 
exonic coordinates, but they do not contain information about the coding 
sequences (CDSs; also known as ORFs) or possible biological functions of 
these transcripts. We previously published 
[*{factR}*](https://fursham-h.github.io/factR/), an R package for the 
construction of CDSs for novel RNA isoforms. *{factR}* also predicts the domain 
organization of the protein products of these isoforms, and it identifies 
transcripts that are susceptible to nonsense-mediated decay (NMD; a pathway 
destabilizing mRNAs with premature translation termination codons).  

This new version of *{factR}*, called *{factR2}*, extends the functionality of its 
predecessor by adding tools to probe for the regulatory potential of alternative 
exons and enhances its user-friendliness by adopting an R object class. 
*{factR2}* can pinpoint splicing events that trigger NMD, and it can also 
test the regulation of alternative splicing by correlating exon inclusion with 
gene expression levels. Additional features of *{factR2}* include direct 
quantification of exonic sequence conservation scores  and an interactive 
visualization of transcript and domain architectures. 

## Getting started

### Installing *{factR2}*

*{factR2}* is currently available on [GitHub](https://github.com/f-hamidlab/factR2) and
can be installed using {devtools}:

```{r, eval=FALSE}
# install.packages("devtools")
devtools::install_github("f-hamidlab/factR2")
```

### Materials needed

*{factR2}* only requires a custom transcriptome file in GTF format as input.
This file is typically generated by short-read assemblers
such as [StringTie2]() and [Cufflinks](), or by long-read aligners such as
[minimap2]() and [Isoquant](). We provide a sample custom transcriptome file 
assembled from PacBio HiFi data using Isoquant that can be used to test 
*{factR2}* functionalities (see "Section" for more details).

Several *{factR2}* functions require reference genomic sequences and 
transcript annotations. To make it easy for users to obtain these files, we 
provide a convenient retrieval system for reference files of common model 
organisms from the GENCODE and Ensembl databases. Users may optionally use 
their own reference files as inputs.


## Using factR2

The following packages are required to follow along this workflow:

```{r setup, eval=FALSE}
library(factR2)
library(tidyverse)
library(rtracklayer)
```

### Creating a _factRObject_

Input custom transcriptome data are stored and analysed as part of an S4 class 
structure called _factRObject_. To create a _factRObject_, users can provide
the local path to their custom GTF file, or a [{GenomicRanges}]() object 
containing transcript architecture information of custom transcriptome. *{factR2}*
comes with a sample GTF file assembled from long-read sequences of transcripts
from postnatal mouse brain cortex (reference). The local path to this GTF file
can be retrieved as such:

```{r}
gtf.file <-  system.file("extdata/pb_custom.gtf.gz", package = "factR2")
```

In addition to a custom GTF file, users are required to define the genome used
for read assembly. This is done by providing input to the `reference` argument
and accepted inputs include the name of the organism ("Homo sapiens" or "Human")
or the specific `ID` of *{factR2}* supported genomes. This list can be retrieved
by typing the function `listSupportedGenomes()` in console as such: 

```{r}
listSupportedGenomes()
```

With these inputs, a _factRObject_ can be created as follows:

```{r, warning=FALSE}
fobj <- createfactRObject(gtf.file, reference = "vM33")
```

The function above extracts and stores gene-, transcript- and exon-level 
information from a custom GTF file and, by default, checks for inconsistencies in
gene annotation to the reference transcriptome.


### Interacting with a _factRObject_

*{factR2}* comes with many functions to access the information stored within a 
_factRObject_. A preview of the object's contents can be printed by typing
the variable name:

```{r}
fobj
```

Transcripts that contain distinct sets of internal exons are defined as "novel".
Note that input custom transcriptome lack coding sequence information and thus,
none of the transcripts are currently annotated as "coding".

Metadata of genes, transcripts and exons are segregated into individual "set"
data in a _factRObject_. At any one time, only one of this "set" will be assigned
as the active "set". Users may switch to a different "set" by assigning the
name of the new "set" to the `activeSet` function:

```{r}
activeSet(fobj) <- "transcript"
```

The exact names of the "set" can be printed out using `listSets()`:


```{r}
listSets(fobj)
```

The metadata associated with the current active "set" can be displayed as a 
dataframe using the `features()` function:

```{r, message=FALSE}
features(fobj)
```

To display the transcripts from your desired genes, users can provide
IDs or names of genes as input to the second argument of `features()`. For
example, to query for the transcripts from U2af1 gene, we can type:
```{r, message=FALSE}
features(fobj, "U2af1")
```

Multiple genes can be displayed by providing additional gene names:

```{r, message=FALSE}
features(fobj, "U2af1", "U2af2")
```

To quickly display the metadata of a different "set", users may modify the `set`
argument:
```{r}
features(fobj, "U2af1", set = "AS")
```

or use a convenient wrapper function (see ?`factR-meta`) for more other wrapper:
```{r}
ase(fobj, "U2af1")
```

TALK ABOUT AS_ids

The dataframe ouputs of `features()` and other convinient wrappers can be assigned 
to a new variable for further wrangling or directly piped to a downstream 
data manipulation function. In the example below, we show how to quickly count the
number of events by the splicing type (AStype):

```{r}
ase(fobj) %>% 
  group_by(AStype) %>% 
  tally()
```




*{factR2}* now c

comes with improvements to the visualisation of transcript 
architectures.

```{r}
plotTranscripts(fobj, "U2af1")
```
Exon structures may sometimes appear thin and inconspicuous especially when the
flanking introms are extremely long. To focus on the exon architectures, users
may set the `rescale_introns` argument to `TRUE`:

```{r}
plotTranscripts(fobj, "U2af1", rescale_introns = T)
```

### Running *factR* pipeline

*{factR2}* contains 5 key functions to probe for biological function of
custom transcripts:

1. `buildCDS()`: to construct CDS information
2. `getAAsequence()`: to translate amino acid sequences
3. `predictNMD()`: to predict for NMD-sensitive transcripts
4. `testASNMDevents()`: to pinpoint splicing events leading to NMD
5. `getAScons()`: to quantify exon-level sequence conservation scores

The above functions can be simultaneously performed by running the `runfactR()`
pipeline and this will update the metadata stored within the _factRObject_:

```{r warning=FALSE}
fobj <- runfactR(fobj)
```

The number of newly-identified coding transcripts is now reflected in the
object summary:
```{r}
fobj
```
Coding transcripts that are predicted to be NMD-sensitive are now annotated
as "yes" under the column "nmd" in the transcript metadata:

```{r, message=FALSE}
features(fobj, "U2af1") 
```

The total number of NMD-sensitive transcripts can be queried as such:

```{r}
features(fobj) %>% 
  group_by(nmd) %>% 
  tally()
```

Now, `plotTranscripts()` will distinguish between CDS and untranslated region (UTR)
segments:
```{r}
plotTranscripts(fobj, "U2af1", rescale_introns = T)
```


By default, the `runfactR` pipeline will compute the sequence conservation scores
of the entire exon. To determine the conservation of intronic sequences flanking
these alternative exons (50 base pairs on each side), 
users may rerun the `getAScons()` function and the newly-computed scores will
be reflected as a separate column in the "AS" set metadata:

```{r}
fobj <- getAScons(fobj, type = "flanks", padding = 50)
ase(fobj)
```



### Testing regulatory function of AS-NMD events

Upon closer inspection of the alternative events from the U2af1 gene, we found
2 out of 3 exons that are predicted to trigger NMD in its host transcript.
These AS-NMD events can be classified as "Stimulating" if the longer form 
(exon inclusion) of the transcript is NMD-sensitive or "Repressing" if the
shorter form (exon skipping) of the transcript is NMD-sensitive.
```{r, message=FALSE}
ase(fobj, "U2af1")
```

This can be visually verified by plotting the transcripts: 
ERROR PROPS UP HERE:

```{r, eval=FALSE}
plotTranscripts(fobj, "AS10419")
```


To further test the regulatory function of these AS-NMD events, we can
correlate the exon inclusion levels (PSI or Percent Spliced In) of 
AS-NMD events to its gene expression
level. *{factR2}* has capabilities to compute gene expression counts and
PSI values from transcript-level expression count matrix. To demonstrate
this feature, we provide a sample transcript count matrix of all detected
isoforms detected in postnatal mouse brain at two development timepoints.
This count matrix can be added to the _factRObject_ using the `addTxCounts()`
function:


```{r}
counts <- system.file("extdata/pb_expression.tsv.gz", package = "factR2")
fobj <- addTxCounts(fobj, counts)
```

Users may choose to use pre-computed PSI values from other splicing quantification
tool by providing the path to the PSI matrix to the `psi` argument.


To test the correlation between exon PSI values and gene expression levels, 
users may use the `testGeneCorr()` function. By default, this function will
perform a two-sided Pearson's product moment correlation on variance-stabilised PSI 
and normalised gene expression expression. Users may customise the parameters
of the correlation test by parsing addition arguments to the R `cor.test()` 
function. In the example below, we show how one would modify the `testGeneCorr()`
function to carry out one-sided test:

```{r}
fobj <- testGeneCorr(fobj,alternative="greater")
```

```{r, message=FALSE}
ase(fobj, "U2af1")
```


```{r, eval=FALSE}
.plot2way(fobj, "AS10419", "U2af1")
```


```{r}
ase(fobj) %>% 
  filter(gene.cor.pval<0.05, 
         ASNMDtype=="Stimulating", 
         AStype=="CE") %>% arrange(desc(gene.cor.estimate))
```



### Predicting protein domains

Print AA sequence?

```{r}
plotDomains(fobj, "U2af1")
```


```{r}
sessionInfo()
```


















