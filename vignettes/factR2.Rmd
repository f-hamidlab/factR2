---
title: "Working with custom transcriptomes using factR2"
author: "Fursham Hamid"  
date: "`r Sys.Date()`"  
output:  
  rmarkdown::html_document:
    highlight: kate
    toc: true
    toc_depth: 3
    number_sections: true
vignette: >  
  %\VignetteIndexEntry{factR}  
  %\VignetteEngine{knitr::rmarkdown}  
bibliography: references.bib 
---

  
```{r setup, echo=FALSE, include=FALSE}  
## Global options  
options(max.print="100")  
knitr::opts_chunk$set(  
  collapse = TRUE,  
  comment = "#>")  
knitr::opts_knit$set(width=75)  

# library load
library(factR2)
library(dplyr)
library(rtracklayer)
```  


# Introduction 

Many eukaryotic genes undergo alternative splicing to produce multiple RNA 
isoforms, thus expanding the coding and regulatory potential of the genome. 
The transcriptome of specific biological samples are constructed from high 
throughput sequencing experiments by mapping short or long reads to a reference 
genome and assembling alignments into transcript architectures. The resulting 
Gene Transfer Format (GTF) files describe newly identified transcripts as sets of 
exonic coordinates, but they do not contain information about the coding 
sequences (CDSs; also known as ORFs) or possible biological functions of 
these transcripts. We previously published 
[*{factR}*](https://fursham-h.github.io/factR/), an R package for the 
construction of CDSs for novel RNA isoforms. *{factR}* also predicts the domain 
organisation of the protein products of these isoforms, and identifies 
transcripts that are susceptible to nonsense-mediated decay (NMD; a pathway 
destabilizing mRNAs with premature translation termination codons).  

This new version of *{factR}*, called *{factR2}*, extends the functionality of its 
predecessor by adding tools to probe for the regulatory potential of alternative 
exons and enhances its user-friendliness by adopting an R object class. 
*{factR2}* pinpoints alternative splicing events that trigger NMD, and it
tests this regulation by correlating exon splicing inclusion with 
gene expression level. Additional features of *{factR2}* include direct 
quantification of exonic sequence conservation scores, an interactive 
visualisation of transcript and domain architectures and a two-way plot of
expression or exon splicing levels.

# Getting started

## Installing *{factR2}*

*{factR2}* is currently available on [GitHub](https://github.com/f-hamidlab/factR2) and
can be installed using {devtools}:

```{r installation, eval=FALSE}
# install.packages("devtools")
devtools::install_github("f-hamidlab/factR2")
```

### Materials needed

*{factR2}* only requires a custom transcriptome file in GTF format as input.
This file is typically generated by short-read assemblers
such as [StringTie2](https://ccb.jhu.edu/software/stringtie/) [@Kovaka2019]  
and [Cufflinks](https://cole-trapnell-lab.github.io/cufflinks/cufflinks/index.html), 
[@Trapnell2012] or by long-read aligners such as
[minimap2](https://github.com/lh3/minimap2) [@Li2018] and 
[Isoquant](https://github.com/ablab/IsoQuant) [@Prjibelski2023]. We provide a 
sample custom transcriptome file assembled from PacBio HiFi data using Isoquant 
that can be used to test *{factR2}* functionalities 
(see ["Creating a _factRObject_"](#Creating-a-factRObject) for more details).

Several *{factR2}* functions require reference genomic sequences and 
transcript annotations. To make it easy for users to obtain these files, we 
provide a convenient system to retrieve reference files of common model 
organisms from the GENCODE and Ensembl databases. Users may optionally use 
their own reference files as inputs.


## Using factR2

The following packages are required to perform this workflow:

```{r loaddep, eval=FALSE}
library(factR2)
library(dplyr)
```

### Creating a _factRObject_

User-input custom transcriptome data are stored and analysed as part of an S4 class 
structure called _factRObject_. To create a _factRObject_, users can provide
the local path to their custom GTF file, or a 
[{GenomicRanges}](https://bioconductor.org/packages/release/bioc/html/GenomicRanges.html) 
object containing transcript architecture information of custom transcriptome. 
*{factR2}* comes with a sample GTF file assembled from long-read sequences of transcripts
from postnatal mouse brain cortex [@Joglekar2023]. The local path to this GTF file
can be retrieved as follows:

```{r getGTF}
gtf.file <-  system.file("extdata/pb_custom.gtf.gz", package = "factR2")
```

In addition to a custom GTF file, users are required to define the genome used
for read assembly. This is done by providing input to the `reference` argument
and accepted inputs include the name of the organism ("Homo sapiens" or "Human")
or the specific `ID` of *{factR2}* supported genomes. This ID list can be retrieved
by running the `listSupportedGenomes()` in console: 

```{r listgenomes}
listSupportedGenomes()
```

With these inputs, a _factRObject_ can be created as follows:

```{r createobj, warning=FALSE}
fobj <- createfactRObject(gtf.file, reference = "vM33")
```

The function above extracts and stores gene-, transcript- and exon-level 
information from a custom GTF file and, by default, corrects for inconsistencies 
in gene annotation to the reference transcriptome.


### Interacting with a _factRObject_

*{factR2}* comes with wrapper functions to access the information stored within a 
_factRObject_. A preview of the object's contents can be printed by typing
the variable name:

```{r display}
fobj
```

Transcripts that contain distinct sets of internal exons are defined as "novel".
Note that the sample GTF lack coding sequence information and thus,
none of the transcripts are currently annotated as "coding".

The metadata of genes, transcripts and exons are segregated into individual "set"
data in a _factRObject_. One of these "set" data will be assigned
as the active "set" and users may switch the active "set" using the 
`activeSet()` function:

```{r setactiveSet}
activeSet(fobj) <- "transcript"
```

The exact names of the "set" can be printed out using `listSets()`:

```{r}
listSets(fobj)
```

The metadata associated with the current active "set" can be displayed as a 
dataframe using the `features()` function:

```{r printfeat, message=FALSE}
features(fobj)
```
To show more columns as an R dataframe, set `show_more` argument to TRUE:

```{r printmorefeat}
features(fobj, show_more = TRUE)
```



To display transcripts expressed from a particular gene, users can provide
IDs or names of genes as input to the second argument of `features()`. For
example, to query for the transcripts from U2af1 gene, we can type:
```{r printgene, message=FALSE}
features(fobj, "U2af1", show_more = TRUE)
```

Multiple genes can be displayed by providing additional gene names:

```{r printmoregenes, message=FALSE}
features(fobj, "U2af1", "U2af2", show_more = TRUE)
```

To quickly display the metadata of a different "set", users may modify the `set`
argument:
```{r printAS}
features(fobj, "U2af1", set = "AS", show_more = TRUE)
```

or use convenient wrapper functions (see ?`factR-meta` for more):
```{r printAS2}
ase(fobj, "U2af1", show_more = TRUE)
```

Each alternative splicing event has been assigned a internal unique ID for easy 
referencing and this can be found in the column "AS_id". 

The above `features()` function and other similar assessor functions outputs
a dataframe that can be saved as a new variable for further wrangling. 
Alternatively, the output dataframe can be directly piped to downstream
functions. In the example below, we show how to quickly count the
number of events by the splicing type (AStype):

```{r tallyAS}
ase(fobj) %>% 
  group_by(AStype) %>% 
  tally()
```


*{factR2}* is pre-built with functions to visualise transcript architectures
on an interactive plot:


```{r plotTx, fig.height=6, fig.width=8}
plotTranscripts(fobj, "U2af1")
```
Exon structures may sometimes appear thin and inconspicuous especially when 
flanking introns are extremely long. To focus on the exon architectures, users
may set the `rescale_introns` argument to `TRUE`:

```{r plotTX2, fig.height=6, fig.width=8}
plotTranscripts(fobj, "U2af1", rescale_introns = T)
```

### Running *factR* pipeline

*{factR2}* contains 5 key functions to probe for biological function of
custom transcripts:

1. `buildCDS()`: to construct CDS information
2. `getAAsequence()`: to translate amino acid sequences
3. `predictNMD()`: to predict for NMD-sensitive transcripts
4. `testASNMDevents()`: to pinpoint splicing events leading to NMD
5. `getAScons()`: to quantify exon-level sequence conservation scores

The above functions can be simultaneously performed by running the `runfactR()`
pipeline and this will update the metadata stored within the _factRObject_:

```{r runfactR, warning=FALSE}
fobj <- runfactR(fobj)
```

The number of newly-identified coding transcripts is now reflected in the
object summary:
```{r dispnew}
fobj
```
Coding transcripts that are predicted to be NMD-sensitive are now annotated
as "yes" under the column "nmd" in the transcript metadata:

```{r printnewgene, message=FALSE}
features(fobj, "U2af1", show_more = TRUE)
```

The total number of NMD-sensitive transcripts can be queried as such:

```{r tallynmd}
features(fobj) %>% 
  group_by(nmd) %>% 
  tally()
```

Now, `plotTranscripts()` will distinguish between CDS and untranslated region (UTR)
segments:
```{r plotTxnew, fig.height=6, fig.width=8}
plotTranscripts(fobj, "U2af1", rescale_introns = T)
```


By default, the `runfactR` pipeline will compute the sequence conservation scores
of the entire exon. To determine the conservation of intronic sequences flanking
these alternative exons (50 base pairs on each side), 
users may rerun the `getAScons()` function and the newly-computed scores will
be reflected as a separate column in the "AS" set metadata:

```{r calcnewcons}
fobj <- getAScons(fobj, type = "flanks", padding = 50)
ase(fobj, show_more = TRUE)
```


### Testing regulatory function of AS-NMD events
AS-NMD events are classified as "Stimulating" if the longer form 
(exon inclusion) of the transcript is NMD-sensitive or "Repressing" if the
shorter form (exon skipping) of the transcript is NMD-sensitive. Both AS-NMD event
types were detected in the U2af1 example:


```{r checkASNMD, message=FALSE}
ase(fobj, "U2af1", show_more = TRUE)
```

This can be visually verified by running `plotTranscripts()` with coordinates
as input: 

```{r plotzoom, eval=TRUE}
plotTranscripts(fobj, "chr17:31870294-31873065")
```

To further test the regulatory function of these AS-NMD events, we can
correlate the exon inclusion levels (PSI or Percent Spliced In) of 
AS-NMD events to its gene expression
level. *{factR2}* can compute gene expression counts and PSI values from 
transcript-level expression count matrices. To demonstrate this, we provide a 
sample transcript count matrix of all detected isoforms in postnatal mouse 
brain at two developmental timepoints.
This count matrix can be added to the _factRObject_ using the `addTxCounts()`
function:


```{r addcounts}
counts <- system.file("extdata/pb_expression.tsv.gz", package = "factR2")
fobj <- addTxCounts(fobj, counts)
```

Users may choose to use pre-computed PSI values from other splicing quantification
tool by providing the path to the PSI matrix to the `psi` argument.

To test the correlation between exon PSI values and gene expression levels, 
users may use the `testGeneCorr()` function. By default, this function will
perform a two-sided Pearson's product moment correlation on variance-stabilised PSI 
and normalised gene expression expression. Users may customise the parameters
of the correlation test by parsing addition arguments to the R `cor.test()` 
function. In the example below, we show how one would modify the `testGeneCorr()`
function to carry out one-sided test:

```{r testcorr}
fobj <- testGeneCorr(fobj, alternative="greater")
```

The above function creates 2 new columns in AS metadata: `gene.cor.estimate` 
which returns the correlation coefficient of the test and `gene.cor.pval` which
returns the unadjusted significant level. For AS-NMD events of type "Stimulating",
the PSI values have been transformed to `1-PSI` so that the correlation coefficient
of values for `gene.cor.estimate` are positive. In our example below,
the AS-NMD stimulating event `AS10419` showed significant correlation with 
U2af gene expression.

```{r checkgenecor, message=FALSE}
ase(fobj, "U2af1", show_more = TRUE)
```

We can plot a two-way plot of U2af1 expression against AS10419 PSI values 
using the `plot2way()` function:


```{r plotcorr, eval=TRUE}
plot2way(fobj, x="AS10419", y="U2af1", plot_trend=TRUE)
```

### Predicting protein domains  
*factR2* can also inspect domain structure of protein products encoded by newly 
identified mRNA isoforms using its `predictDomains()` function. This function
requires connection to the online PFAM database and may require a substantial 
amount of time and stable internet connection to query multiple transcripts 
simultaneously. To quickly explore and visualise the output of the 
`predictDomains()` tool, user may prefer to use the `plotDomains()` function.
For example, the following will predict domain structure for all transcripts
of the U2af1 gene:

```{r plotdom, fig.height=6, fig.width=8, message=FALSE}
plotDomains(fobj, "U2af1")
```


If you want to predict domains for all new transcripts and do not mind waiting 
for some time depending on the connection speed and the PFAM server load, 
run the following:
```{r predDomain1, eval=FALSE}  
fobj <- predictDomains(fobj)  
```


  
### Export output objects  

The _factRObject_ can be saved as an RDS file and restored later for further
analysis:

```{r exportfobj, eval=FALSE}  
saveRDS(fobj, "factRObject.rds")
```  

Key data stored in a _factRObject_ (updated GTF file and metadata files) can be
exported as text files in the local workding directory using the `exportAll` 
function:

```{r exportdat, eval=FALSE}  
exportAll(fobj) 
```  

Alternatively, users may use the `exportGTF()` and `exportTable()` functions
to export individual data:

```{r exportindividual, eval=FALSE}  
exportGTF(fobj)
exportTable(fobj, data = "transcript")  # data can be "gene", "transcript" or "AS"
```  


# Session Information  
This workflow was conducted on:  
```{r sessioninfo}  
sessionInfo()  
```  
  

# References  
 
















